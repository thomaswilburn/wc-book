<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Custom element fundamentals</title>
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Manuale" rel="stylesheet">
  <link rel="stylesheet" href="static/style.css">
  <link rel="stylesheet" href="static/highlight/hybrid.css">

  <!-- BEGIN TWITTER SUMMARY CARD -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Custom element fundamentals">
  <meta name="twitter:site" content="@thomaswilburn">
  <meta name="twitter:image" content="https://thomaswilburn.github.io/wc-book/static/social.jpg">
  <meta name="twitter:description" content="">

  <!-- Social sharing meta -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Custom element fundamentals">
  <meta property="og:site_name" content="Web Components at Work">
  <meta property="og:image" content="https://thomaswilburn.github.io/wc-book/static/social.jpg">
  <meta property="og:description" content="">

</head>
<body class="ce-intro section-intro">
  <nav class="chapter-links top">
    <ul>
      <li class="previous"> <a rel="prev" href="intro.html"> &laquo; Introduction</a>
      <li> <a href="index.html">&bigstar;</a>
      <li class="next"> <a rel="next" href="ce-definition.html"> Defining your element &raquo;</a>
    </ul>
  </nav>
  <main>
  <aside class="summary">
    
  </aside>
  <h1>Custom element fundamentals</h1>
<p>There's not a lot of agreement in the JavaScript framework world, but the one thing that everyone has largely taken for granted is that it's a Good Thing to be able to declare units of functionality &mdash; components &mdash; and then arrange them into HTML-ish markup. And for good reason: HTML is a clear and easy-to-understand language, and structuring your application this way tends to form a good abstraction over the actual page that the browser uses.</p>
<p>These framework components are only an abstraction, however. Inspecting a React or Vue application in a stock browser, you'll only see the rendered markup from the component templates, not the component "elements" themselves or their state. In order to see the page the way the framework sees it, you'll need to install an add-on for the developer tools that can translate back into its pre-compiled form &mdash; like a reverse version of the sunglasses from <i>They Live</i>.</p>
<p>The custom elements API also lets us build components that we can organize into an HTML tree, with one crucial difference: these aren't abstractions, but actual elements that the browser renders directly. They can be inspected without special tooling, and created or altered using the same DOM methods that you would use on an ordinary <var>&lt;div&gt;</var> or <var>&lt;img&gt;</var>.</p>
<p>It also has some drawbacks, as we'll see: integrating into the DOM means taking on some of its flaws. But its advantages &mdash; interoperability not just with other custom elements, but with framework code as well &mdash; make it a powerful tool at the heart of the web component concept.</p>
  </main>
  <nav class="chapter-links bottom">
    <ul>
      <li class="previous"> <a rel="prev" href="intro.html"> &laquo; Introduction</a>
      <li> <a href="index.html">&bigstar;</a>
      <li class="next"> <a rel="next" href="ce-definition.html"> Defining your element &raquo;</a>
    </ul>
  </nav>
</body>
</html>
